##Nearsoft Academy
**Month #1**  
**Book Review of “The Pragmatic Programmer”**  
**Coursera Online Course: “Learning How to Learn”**  
**Cesar Dario Garcia Jiménez (Nearsoft Academy)**  
**cgarcia@nearsoft.com**  


##“The Pragmatic Programmer”  
##From Journeyman to Master  
By:  
Andrew Hunt & David Thomas  
  
Pragmatic:  
adjective: pragmatic  
##1. dealing with things sensibly and realistically in a way that is based on practical rather than theoretical 
considerations.  
  
What does it mean to be a pragmatic programmer?    
Attitude, style and a philosophy of approaching problems and their solutions.  
  
The pragmatic philosophy is about dealing the existing problems with a professional and practical approach, it requires you
to take things seriously and understand the big and the little things that are involved in the software development 
cycle and make use of the knowledge and good practices that will allow you to create software in state of art.
   
What makes a pragmatic Programmer?    
Each developer is unique with their own strengths and weaknesses and they plasm their individuality in their work, but a
pragmatic programmer must share some qualities:  
  
Early adopter / fast adapter: A developer who is not afraid of trying new things and adapt to change. The developer becomes 
more confident as it experience growth.  
  
Inquisitive: Naturally curious, it is a natural thing for humans to be curious, don't let that curiosity be ever satisfied.  
Critical Thinker: Put under test everything you see and make use of your capacity to analyze things objectively always.
Realistic: Understand the underlaying nature in every problem will give you a good sense of the real magnitude of things.
Jack of all trades: You are able to move into all kind of different areas that emerge in technology, even if your job requires you to be a specialist.
The book is divided into 8 chapters with the concepts, the principles behind the concepts, exercises and tips to 
summarize the learnings.
  
The list of tips from the book covers all kinds of situations to have in mind during the software development cycle, 
it is based on the experience of many developers through many years, and it's knowledge applied will give you the power 
to become a true pragmatic programmer.
  
We found the lists of tips as the core of this book so we present it in here:  
  
##Tip 1: Care About Your Craft  
It's not enough only “do it”. Do it the best. Think that if user would be happy —or at less comfortable— using the software that is being developed.
##Tip 2: Think! About Your Work  
Coding is the less important thing where someone is programming. Programming is a mental work and it's because anyone could type at the keyboard. 
##Tip 3: Provide Options, Don't Make Lame Excuses  
Programmers also are humans. And humans make mistakes. So, everyone will fail at some point of his work. And that is not bad. There are more learning when you receive “negative” feedback than when you only listen applauses. But actions always have consequences. So, when you get it wrong, explain why it is wrong and at the same times provide options about how correct it. Don't try to invent excuses. Nobody care. They are useless for resolving a problem. 
##Tip 4: Don't Live with Broken Windows  
The book propose a story. It tells that there were an experiment in a neighborhood where everything was OK. But when they broke a window, the graffiti and vandalism started. They compare the broken windows with wrong decision, bad designs or poor code. When something is wrong in the project, that will spread in the rest. And graffiti (spaghetti code or something worst) will come up and it will destroy the entire project. 
##Tip 5: Be a Catalyst for Change  
The stone soup is quoted here. When something seems wrong or you think that is needed change it, don't wait that someone else do it. Take the stones and invite to everybody to take the potatoes, the carrots and the meat. Take initiative. 
##Tip 6: Remember the Big Picture  
This is not only for programming. Even Barbara Oakley (from Learning how to Learn) suggested that. Sometimes we are tempted to forget the primary purpose of doing the project, or what we really need to do, because we are focused in a small thing that could be useless. So, remembering the big picture let us visualize the whole and get a better comprehension about how important —or not— that aspect or feature really is. And take our major strengthens in the really vital. 
##Tip 7: Make Quality a Requirements Issue  
Quality is not optional. If we leave to the end of the project, then there will not much to do. And there is a relationship with the first tip. A system should be developed in the better way as possible. 
##Tip 8: Invest Regularly in Your Knowledge Portfolio   
As we have learned in this weeks, everything tends to change all the time. It's good to be continuously prepared for those changes. Always learning new programming languages, for example, would be a great way to improve the portfolio.  
##Tip 9: Critically Analyze What You Read and Hear   
Critical thinking is mandatory not only for designing but for taking criteria about what to learn and what not. What reading is true and what could be false. 
##Tip 10: It's Both What You Say and the Way You Say It  
We are humans. Every time. And we are working in a team. Humans are not computers that only receive orders. Take a time in order to think what and how to say anything and that could bring amazing results.   
##Tip 11: DRY
One of the most important principle in the book. Its meaning could be endless. Repeating complicates the work instead of  reaffirm it. Repeat anything, and you will have to repeat the review, the correctness and the problems. When something change, you will be falling in a huge waterfall where you wouldn't know how to stop. 
Even when duplication seems legit and necessarily, don't do it! Always try to:
##Tip 12: Make It Easy to Reuse.
DRY. And, why to work double?
##Tip 13: Eliminate Effects Between Unrelated Things
One more of the principles for OO Programming. High cohesion and low coupling. What should I need to change if a requirement change? In order to make refactoring (and life) easier, give to things one single responsibility

##Tip 14: There are no final decisions.
All can change. And all will do it, eventually. Not only for requirements but the ways for making anything. If you have learned how to do it something and that results useless, try a different way.

##Tip 15: Use Tracer Bullets to Find the Target
«You use the technique in situations where you're not 100% certain of where you're going. You shouldn't be surprised if your first couple of attempts miss: the user says "that's not what I meant," or data you need isn't available when you need it, or performance problems seem likely».
##Tip 16: Prototype to Learn
What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system.
Architecture, new functionality in an existing system, structure or contents of external data, third-party tools or components, performance issues or user interface design.
When used properly, a prototype can save you huge amounts of time, money, pain, and suffering by identifying and correcting potential problem spots early in the development cycle—the time when fixing mistakes is both cheap and easy.
##Tip 17: Program Close to the Problem domain
In order to get a better understanding from the system use the proper language. 
##Tip 18: Estimate to Avoid Surprises
The only way to determine the timetable for a project is by gaining experience on that same project. So, there are no possibilities from exactly knowing how a project will be result. Try to estimate in similar projects, but be prepared to surprises. Not, try to predict them based on what you had learned before.
##Tip 19: Iterate the Schedule with the Code
What to Say When Asked for an Estimate? You say "I'll get back to you." You almost always get better results if you slow the process down and spend some time going deeper and analyze the things well. However it's almost impossible give a first trust estimate. If customer understand that, you could try to iterate the planning and, about learned, you would give him a schedule in the second or third iteration.
##Tip 20: Keep Knowledge in Plain Text
As Pragmatic Programmers, our base material isn't wood or iron, it's knowledge. It should be useful and accessible not only for reading but other programs access it. Plain text instead of binary format is the best option for that. You could handle plain text easier.
##Tip 21: Use the Power of Command Shells
The shell commands may be obscure or terse, but they are powerful and concise. Any linuxer knows it. It gives you access to “The Matrix”. Or not. But it let you control your entire system while other GUI based tools doesn't.
##Tip 22: Use a Single Editor Well
Knowledge is the main weapon for programmers. Accessing to it fast and easily and shot to the problems could be the difference between win or die in the war. A good editor should be:
Configurable.
Extensible.
Programmable.
Syntax highlighting
Auto-completion
Auto-indentation
Initial code or document boilerplate
Tie-in to help systems
IDE-like features (compile, debug, and so on)
##Tip 24 Fix the Problem, Not the Blame
Progress, far from consisting in change, depends on retentiveness. Those who cannot remember the past are condemned to repeat it. It is a painful thing. To look at your own trouble and know That you yourself and no one else has made it
##Tip 25: Don't Panic
Simply. There is always a way to do successful anything. Just relax and try it differently. 
##Tip 26: "select" Isn't Broken
This tip was thought from a issue in code, where developer blame to DBMS saying that the “select” statement didn't work properly. Ha. But he had a bug. But it was easier to blame another. In order to avoid that:
Start:
make sure that you are working on code that compiled cleanly—without warnings
Accuracy in bug reports is further diminished when they come through a third party
You may need to interview the user who reported the bug in order to gather more data than you were initially given.
Artificial tests (such as the programmer's single brush stroke from bottom to top) don't exercise enough of an application. You must brutally test both boundary conditions and realistic end-user usage patterns.
Strategies:
Bug Reproduction
Visualize Your Data
Tracing
explaining the problem to another person
##Tip 27: Don't Assume It—Prove It
It's not enough only “know” that something is fine. At science, everything could be proved. 
##Tip 28: Learn a Text Manipulation Language
These languages are important enabling technologies. Using them, you can quickly hack up utilities and prototype ideas—jobs that might take five or ten times as long using conventional languages
##Tip 29: Write Code That Writes Code
DRY. Automatize. And so on. 
##Tip 30: You Can't Write Perfect Software
Live with it. And always be aware what you have write. It has bugs!
##Tip 31: Design with Contracts
What is a correct program? One that does no more and no less than it claims to do.
Preconditions.
Postconditions.
Class invariants
If all the routine's preconditions are met by the caller, the routine shall guarantee that all postconditions and invariants will be true when it completes.
A contract is a kind of programming, where a preprocessor take an input (that could be used like documentation or meta data) and transforming it into a skeleton code. This has relationship with DRY. 
##Tip 32: Crash Early
Pragmatic Programmers tell themselves that if there is an error, something very, very bad has happened. Do it fast in order to loss less.

##Tip 33 If It Can't Happen, Use Assertions to Ensure That It Won't
Most of programming languages provides this features. 
##Tip 34 Use Exceptions for Exceptional Problems
And don't do it with simple problems that could be handle in an if/else clausule.
##Tip 35 Finish What You Start
This is more focused to system's resources, like files or database connections. Follow this steps:
1. Deallocate resources in the opposite order to that in which you allocate them. That way you won't orphan resources if one resource contains references to another.
2. When allocating the same set of resources in different places in your code, always allocate them in the same order. This will reduce the possibility of deadlock.
Law of Demeter Functions
attempts to minimize coupling between modules in any given program.
##Tip 36: Minimize coupling between modules
We need to make every effort to write code that's as loose—as flexible—as possible. A good way to stay flexible is to write less code. The less possible. 
You could write "shy" code, that works two ways: don't reveal yourself to others, and don't interact with too many people.
Organize your code into cells (modules) and limit the interaction between them.
##Tip 37 Configure, Don't Integrate
It's easier modify a properties file than alter the code source when some change is presented. Meta data allows you to reach this goal. 
##Tip 39: Analyze Work flow to Improve Concurrency
You can use activity diagrams to maximize parallelism by identifying activities that could be performed in parallel, but aren't. Be prepared and optimize analyzing the entire work flow.
##Tip 40: Design Using Services
Instead of components, create services independent, concurrent objects behind well-defined, consistent interfaces that allow accessing to data.
##Tip 41: Always Design for Concurrency
Because it could pass. Some components, user or whatever trying to access to the same resource. 
##Tip 42: Separate Views from Models
This architecture is a good example of giving a single responsibility to each component and low coupling. So you can reuse models in different views and you won't lose your head at maintain phase.
##Tip 43 Use Blackboards to Coordinate Workflow
Where anyone could write asynchronously and check what they need. In a single repository.
##Tip 44 Don't Program by Coincidence
Coding is not mechanical. It's more an art than an simple craft. Beginners frequently make the mistake of start to type before think. Coding has a purpose. Don't lose it. 
##Tip 45 Estimate the Order of Your Algorithms
In order to get the best performance you can. And improve the quality. And do the user happy in a world where each millisecond counts even no one is able to sense it.
##Tip 46 Test Your Estimates
Prove if you were right or not, and learn about what was wrong.
##Tip 47: Refactor Early, Refactor Often
Code needs to evolve; it's not a static thing. Most IDE or tools are capable of doing this. Things can always be improved. Some piece of code that seems not comprehensible or something duplicated could be refactorized. Coupled modules also do.
##Tip 48 Design to Test
We want to write test cases that ensure that a given unit honors its contract. If we do this we could be advertised faster when something is wrong.
##Tip 49: Test Your Software, or Your Users Will
All software you write will be tested—if not by you and your team, then by the eventual users. It's preferable that you notice the error instead an angry customer come up with it. 
##Tip 50 Don't Use Wizard Code You Don't Understand
Because if something is needed to be improved, you will crashed, and probably the system too.
##Tip 51: Don't Gather Requirements—Dig for Them
Underlying requirements are always there and you have to be able to find them.

##Tip 52: Work with a User to Think Like a User
In order to make the system the more realistic and easy to users.
##Tip 53 Abstractions Live Longer than Details
It's probable that detail of requirements will be changed. But if abstraction is well used, you could still use it and only focus in change the detail and not the entire implementation.
##Tip 54 Use a Project Glossary
And each member of the team (developer, designer, even the customer) will be able to understand what are specified in documentation.
##Tip 55 Don't Think Outside the Box— Find the Box
Is there an easier way? Are you trying to solve the right problem, or have you been distracted by a peripheral technicality?
Why is this thing a problem?
What is it that's making it so hard to solve?
Does it have to be done this way?
Does it have to be done at all?
##Tip 56 Listen to Nagging Doubts—Start When You're Ready

##Tip 57 Some Things Are Better Done than Described
Program specification is the process of taking a requirement and reducing it down to the point where a programmer's skill can take over.
##Tip 58 Don't Be a Slave to Formal Methods
Try to adapt the methodology to project and not reverse. Nothing is written in a stone and could be changed. 
##Tip 59 Expensive Too Do Not Produce Better Designs

##Tip 60: Organize Around Functionality, Not Job Functions
Quality is a team issue. Teams as a whole should not tolerate broken windows—those small imperfections that no one fixes. The team must take responsibility for the quality of the product
It is a mistake to think that the activities of a project—analysis, design, coding, and testing—can happen in isolation.
This separation tends to result in a communication issue where no one knows what the other division is working on.
##Tip 61: Don't Use Manual Procedures
People just aren't as repeatable as computers are. Nor should we expect them to be.
##Tip 62: Test Early. Test Often. Test Automatically.
It's just like Google, Netflix and others big companies do it. We are driven to find our bugs now, so we don't have to endure the shame of others finding our bugs later.
##Tip 63 Coding Ain't Done 'Til All the Tests Run
Knowing that you've passed the test gives you a high degree of confidence that a piece of code is "done." 
##Tip 64 Use Saboteurs to Test Your Testing
The saboteur's role is to take a separate copy of the source tree, introduce bugs on purpose, and verify that the tests will catch them.
##Tip 65 Test State Coverage, Not Code Coverage
Code coverage is a good metric but not the perfect one. Even with 100% code coverage could be states that were not covered and test would be useless.
Tip 66 Find Bugs Once
Once a human tester finds a bug, it should be the last time a human tester finds that bug. 
##Tip 67 Treat English as Just Another Programming Language
In order to make code and documentation more readable. 
##Tip 68 Build Documentation In, Don't Bolt It On
Internal documentation includes source code comments, design and test documents, and so on. External documentation is anything shipped or published to the outside world, such as user manuals. 
##Tip 69 Gently Exceed Your Users' Expectations
Always do it the best. And give a “pilon”. Give some extra value to users. Something that makes them smile and become using your product a delightful.
##Tip 70 Sign Your Work
Take ownership about what you have made. Just like my mentor had said to me,  «try to take ownership whenever you can, it’s a great way to exercise leadership and social skills».


##Online Course:

##“Learning How To Learn:   
Powerful mental tools to help you master tough subjects”  
By:  
Dr. Barbara Oakley & Dr. Terrance Sejnowski  

This course gives you access to invaluable learning techniques and the processes of the brain that are behind all that, you will understand the two main states of the brain that helps you to learn and solve problems with a different approach, how to boost your creativity and improve your understanding and memory  of things using metaphors and analogies and how to combat some of the negative habits and beliefs that lies around learning in our times.

This course is divided in four weeks, each one aboard the different aspects involved in learning and the techniques that will help you to improve your learning.

##Week 1  

The first week of the course presents one of the most important and useful process involved in learning and solving problems: The Focused Mode & The Diffuse Mode.

Our brains never stop working over the things you are trying to solve or learn, and it is always shuffling between these two states of mind, you can get the most of each one by understanding how the work.

Focused Mode Thinking: When you intently focus on a problem, your brain makes quick and similar attempts to solve it.

Diffuse Mode Thinking: Diffuse mode is useful when you are trying to learn something new, this way you brains start jumping on ideas and concepts looking for answers in a creative way.

You can take advantage from this two modes when trying to learn or understand something, if the answer doesn't come while you are in focused mode, you can try to switch to the diffuse mode and try aboard the topic in a more creative way and then return to focused mode.

In week 1 we also learned that when you are trying to learn something, it is best to learn it part by part, in repeated study sessions over days, weeks or months to let it be impressed in your long time memory, instead of trying to study something in one exhaustive day, because “Repetition makes permanent”.

Last but not less important is to take care of your brain and body, to sleep is extremely important for your brain when you are trying to learn something, during sleep your brain eliminates all the toxins that are naturally formed during your day, you must sleep well if you want to have your brain functioning well. Exercise is another activity that helps your brain to protect neurons and create more when you sleep, besides that all your body gets beneficiary by this.

Sleep & Exercise well!.

##Week 2  

In week 2 the importance of chunking information is revealed.

Hearing a song does not allows you to automatically play it, so how do yo effectively learn how to play it?

Chunks: When you are trying to absorb some information, it is much better to split that information into “Chunks” to learn it by compact pieces.
 
Chunking information can be tricky because it not useful to only split information as isolated parts, the effective process requires you to understand the meaning of the concept or the information that you are trying to understand, that way you can effectively split information into chunks that preservers their relationship through meaning.

You can get a visual idea of the effective process of chunking in here:










Now that you know how to split information to be effectively understandable for your brain the next step is to make sure you created a “useful” piece of chunk, that means that you really understand something and the concept has becoming a living part of you.


How can we ensure we learned something?

It is possible for you to think that you already learned something but, when the time of using that knowledge you realize that you haven't fully understand it yet.

One of the most effective techniques to understand information and ensure it is becoming part of your long term memory is to do “Recalls” of what you just read, many people had the habit of highlight text or rewrite what they are trying to learn but this is not as effective as doing a Recall and it can even be bad because sometimes you get the false feeling of learning something when you are really not.

Recall consist getting some information, turn to do some other thing and then try to remember and explain to yourself what you learned just a moment ago, according to studies it is one of the most effective techniques for learning.

You can add the concept of “Interleaving” with your Recalls, interleaving means to study and recalling repeatedly but in spaced times, repetition allows your brain to consolidate learnings in the long term memory of your brain.

An interesting concept to present in here is the “Einstellung” effect, it is a Germany word that means Mind Set and it is used to describe something that happened when you learn something really good, but can be a negative thing sometimes.

When you learn something really good, your brains create a strong neuronal circuit to remember the solution you already found, but this can prevent you from learning a better solution or a different approach over something, this is why focused and diffused mode can be useful to trigger the creative process over the things you already know.


##Week 3  

In week 3 we talk about Habits and how to use them to help your learnings.

There are some habits that can be negative for your learning, but you can change them for good ones to improve.

Procrastination: One of the baddest habits, the zombie habit.

Procrastination is a reaction in zombies (humans acting without consciousness), and it is the result of a negative feeling when trying to focus with the wrong attitude, when the negative feeling triggers your to procrastinate it is necessary to take control over the situation change the bad habit over a good one and be human again.

The technique that help us to combat procrastination is conformed by two parts:
Part 1: Focus on the Process NOT the Product, when you focus on the product your mind get stressed over the deadlines and the amount of work that is needed to get that product, on the other side when you focus on the process you focus only on the most immediate action you need to take, and your mind relaxes more.

Part 2: Even when you are focusing on the process or studying something that you like, bad feelings can appear, the thing is HOW you manage those feelings, it is normal to feel bad sometimes but you can change your attitude to a positive position and your brain will change his chemistry and it will work on your side to combat procrastination.

The adequate manage of your habits will help you to learn better, focus on the process not the product, change your attitude, chunk the information and use the focus and the diffuse mode in spaced study sessions along with the use of analogies and metaphors, do recall of your learnings but being aware of no falling into the Einstellung effect.

Now another think to keep in mind is that you have 2 different areas in your memory where everything you learn is stored, the Working Memory & your Long Term memory, working memory is like a blackboard where you can work with the things you are dealing immediately, long term memory is where the strongest neuronal connections conforms allowing to remember things better.


##Week 4:  

Week 4 helps you to reinforce what you learned in the previous weeks of the course.
You can become a better learning no matter how your background is, there are some advices that can help you go along in your way, because if you change your though you can really truly change your mind.

Even if you feel like you are not the most gifted person for learning and understanding things, definitely you can learn and master anything you want if you persevere.

“Perseverance is a virtue of the less brilliant” (Santiago Ramon y Cajal). 

Change your Attitude and get rid of the the negative beliefs that stops you from being a great learner.

Face your fears and change your thoughts!.
